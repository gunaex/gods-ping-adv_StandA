"""
Trading Bots Service
Grid Bot, DCA Bot, and Gods Hand Autonomous Trading
"""
import asyncio
from datetime import datetime, timedelta
from typing import Dict, Optional
from sqlalchemy.orm import Session
from app.models import BotConfig, Trade
from app.market import get_current_price, execute_market_trade
from app.ai_engine import get_trading_recommendation, calculate_risk_assessment
from app.logging_models import Log, LogCategory, LogLevel
from app.position_tracker import get_current_position, calculate_incremental_amount
import json
from app.db import get_db


# Bot status tracking (in-memory, use Redis in production)
bot_status = {}
bot_tasks = {}


async def start_grid_bot(user_id: int, config: BotConfig, db: Session) -> dict:
    """
    Start Grid Trading Bot
    Places buy/sell orders at predefined price levels
    """
    if f"grid_{user_id}" in bot_status:
        return {"status": "error", "message": "Grid bot already running"}
    
    bot_status[f"grid_{user_id}"] = "running"
    
    try:
        symbol = config.symbol
        lower_price = config.grid_lower_price
        upper_price = config.grid_upper_price
        levels = config.grid_levels
        budget = config.budget
        
        # Calculate grid levels
        price_step = (upper_price - lower_price) / levels
        grid_levels_prices = [lower_price + i * price_step for i in range(levels + 1)]
        
        # Calculate amount per level
        amount_per_level = budget / levels
        
        # Get current price
        ticker = await get_current_price(symbol)
        current_price = ticker['last']
        
        # Paper trading simulation
        if config.paper_trading:
            trades_placed = []
            
            # Place buy orders below current price
            for price in grid_levels_prices:
                if price < current_price:
                    trade = Trade(
                        user_id=user_id,
                        symbol=symbol,
                        side="BUY",
                        amount=amount_per_level / price,
                        price=price,
                        filled_price=price,
                        status="completed_paper",
                        bot_type="grid",
                        timestamp=datetime.utcnow()
                    )
                    db.add(trade)
                    trades_placed.append({"side": "BUY", "price": price})
                
                # Place sell orders above current price
                elif price > current_price:
                    trade = Trade(
                        user_id=user_id,
                        symbol=symbol,
                        side="SELL",
                        amount=amount_per_level / price,
                        price=price,
                        filled_price=price,
                        status="completed_paper",
                        bot_type="grid",
                        timestamp=datetime.utcnow()
                    )
                    db.add(trade)
                    trades_placed.append({"side": "SELL", "price": price})
            
            db.commit()
            
            return {
                "status": "success",
                "mode": "paper",
                "symbol": symbol,
                "grid_levels": grid_levels_prices,
                "trades_placed": len(trades_placed),
                "message": f"Grid bot started (paper trading) with {levels} levels"
            }
        
        else:
            # Real trading (simplified - full implementation requires order monitoring)
            return {
                "status": "success",
                "mode": "live",
                "symbol": symbol,
                "message": "Grid bot started (live trading)",
                "note": "Full implementation requires continuous order monitoring"
            }
            
    except Exception as e:
        bot_status[f"grid_{user_id}"] = "error"
        return {"status": "error", "message": str(e)}


async def start_dca_bot(user_id: int, config: BotConfig, db: Session) -> dict:
    """
    Start DCA (Dollar Cost Averaging) Bot
    Buys at regular intervals regardless of price
    """
    if f"dca_{user_id}" in bot_status:
        return {"status": "error", "message": "DCA bot already running"}
    
    bot_status[f"dca_{user_id}"] = "running"
    
    try:
        symbol = config.symbol
        amount_per_period = config.dca_amount_per_period
        interval_days = config.dca_interval_days
        
        # Get current price
        ticker = await get_current_price(symbol)
        current_price = ticker['last']
        
        # Calculate buy amount
        buy_amount = amount_per_period / current_price
        
        if config.paper_trading:
            # Execute paper trade
            trade = Trade(
                user_id=user_id,
                symbol=symbol,
                side="BUY",
                amount=buy_amount,
                price=current_price,
                filled_price=current_price,
                status="completed_paper",
                bot_type="dca",
                timestamp=datetime.utcnow()
            )
            db.add(trade)
            db.commit()
            
            next_buy = datetime.utcnow() + timedelta(days=interval_days)
            
            return {
                "status": "success",
                "mode": "paper",
                "symbol": symbol,
                "amount": buy_amount,
                "price": current_price,
                "next_buy": next_buy.isoformat(),
                "message": f"DCA buy executed (paper). Next buy in {interval_days} days"
            }
        else:
            # Real trading
            result = await execute_market_trade(user_id, symbol, "BUY", buy_amount, db)
            
            return {
                "status": "success",
                "mode": "live",
                "result": result,
                "message": "DCA buy executed (live)"
            }
            
    except Exception as e:
        bot_status[f"dca_{user_id}"] = "error"
        return {"status": "error", "message": str(e)}


async def gods_hand_once(user_id: int, config: BotConfig, db: Session) -> dict:
    """Execute one Gods Hand iteration (no status mutations)."""
    symbol = config.symbol

    # Get AI recommendation and risk
    recommendation = await get_trading_recommendation(symbol, config)
    risk_assessment = await calculate_risk_assessment(symbol, config)

    action = recommendation.get('action', 'HOLD')
    confidence = recommendation.get('confidence', 0.0)

    # Log AI thinking
    thinking_log = Log(
        timestamp=datetime.utcnow(),
        category=LogCategory.AI_THINKING,
        level=LogLevel.INFO,
        message=f"AI recommendation for {symbol}: {action} @ confidence {confidence}",
        details=json.dumps({
            "recommendation": recommendation,
            "risk_assessment": risk_assessment,
            "signal_breakdown": recommendation.get('signal_breakdown', []),
            "confidence_calculation": f"Average of {len(recommendation.get('signal_breakdown', []))} indicator signals"
        }, indent=2),
        user_id=user_id,
        symbol=symbol,
        bot_type="gods_hand",
        ai_recommendation=action,
        ai_confidence=str(confidence),
    )
    db.add(thinking_log)
    db.commit()

    # Confidence gate
    if confidence < config.min_confidence:
        action_log = Log(
            timestamp=datetime.utcnow(),
            category=LogCategory.AI_ACTION,
            level=LogLevel.INFO,
            message=f"Gods Hand HOLD: confidence {confidence} < min {config.min_confidence}",
            details=json.dumps({
                "reason": "low_confidence",
                "min_confidence": config.min_confidence,
            }),
            user_id=user_id,
            symbol=symbol,
            bot_type="gods_hand",
            ai_recommendation=action,
            ai_confidence=str(confidence),
            ai_executed="no",
            execution_reason=f"Confidence {confidence} below minimum {config.min_confidence}"
        )
        db.add(action_log)
        db.commit()
        return {
            "status": "hold",
            "mode": "paper" if config.paper_trading else "live",
            "symbol": symbol,
            "action": "HOLD",
            "confidence": confidence,
            "reason": f"Confidence {confidence} below minimum {config.min_confidence}",
            "recommendation": recommendation,
            "risk_assessment": risk_assessment
        }

    # Execute recommendation
    if action in ['BUY', 'SELL']:
        amount = risk_assessment['recommended_position_size']
        current_price = risk_assessment['current_price']

        if config.paper_trading:
            trade = Trade(
                user_id=user_id,
                symbol=symbol,
                side=action,
                amount=amount / current_price if action == 'BUY' else amount,
                price=current_price,
                filled_price=current_price,
                status="completed_paper",
                bot_type="gods_hand",
                timestamp=datetime.utcnow()
            )
            db.add(trade)
            db.commit()

            action_log = Log(
                timestamp=datetime.utcnow(),
                category=LogCategory.AI_ACTION,
                level=LogLevel.INFO,
                message=f"Gods Hand executed {action} (paper)",
                details=json.dumps({
                    "amount": amount,
                    "price": current_price,
                }),
                user_id=user_id,
                symbol=symbol,
                bot_type="gods_hand",
                ai_recommendation=action,
                ai_confidence=str(confidence),
                ai_executed="yes",
            )
            db.add(action_log)
            db.commit()

            return {
                "status": "success",
                "mode": "paper",
                "action": action,
                "symbol": symbol,
                "amount": amount,
                "price": current_price,
                "confidence": confidence,
                "recommendation": recommendation,
                "risk_assessment": risk_assessment,
                "message": f"Gods Hand executed {action} (paper trading)"
            }
        else:
            trade_amount = amount / current_price if action == 'BUY' else amount
            result = await execute_market_trade(user_id, symbol, action, trade_amount, db)

            action_log = Log(
                timestamp=datetime.utcnow(),
                category=LogCategory.AI_ACTION,
                level=LogLevel.INFO,
                message=f"Gods Hand executed {action} (live)",
                details=json.dumps({
                    "trade_amount": trade_amount,
                    "result": result,
                }),
                user_id=user_id,
                symbol=symbol,
                bot_type="gods_hand",
                ai_recommendation=action,
                ai_confidence=str(confidence),
                ai_executed="yes",
            )
            db.add(action_log)
            db.commit()
            
            # Persist live trade record for performance stats
            try:
                live_trade = Trade(
                    user_id=user_id,
                    symbol=symbol,
                    side=action,
                    amount=trade_amount,
                    price=result.get('price') or current_price,
                    filled_price=(result.get('price') or current_price),
                    status=result.get('status') or 'completed_live',
                    bot_type='gods_hand',
                    timestamp=datetime.utcnow()
                )
                db.add(live_trade)
                db.commit()
            except Exception:
                # Do not fail loop if persisting trade fails
                pass

            return {
                "status": "success",
                "mode": "live",
                "action": action,
                "result": result,
                "confidence": confidence,
                "recommendation": recommendation,
                "risk_assessment": risk_assessment,
                "message": f"Gods Hand executed {action} (live trading)"
            }
    else:
        action_log = Log(
            timestamp=datetime.utcnow(),
            category=LogCategory.AI_ACTION,
            level=LogLevel.INFO,
            message="Gods Hand HOLD recommendation",
            user_id=user_id,
            symbol=symbol,
            bot_type="gods_hand",
            ai_recommendation="HOLD",
            ai_confidence=str(confidence),
            ai_executed="no",
            execution_reason="Recommendation HOLD"
        )
        db.add(action_log)
        db.commit()
        return {
            "status": "hold",
            "mode": "paper" if config.paper_trading else "live",
            "symbol": symbol,
            "action": "HOLD",
            "confidence": confidence,
            "recommendation": recommendation,
            "risk_assessment": risk_assessment,
            "message": "Gods Hand recommends HOLD"
        }


async def _gods_hand_loop(user_id: int, interval_seconds: int):
    """Background loop to run Gods Hand periodically until stopped."""
    key = f"gods_hand_{user_id}"
    bot_status[key] = "running"
    try:
        while bot_status.get(key) == "running":
            # Fresh DB session each iteration
            dbi = next(get_db())
            try:
                config = dbi.query(BotConfig).filter(BotConfig.user_id == user_id).first()
                if not config or not config.gods_hand_enabled:
                    await asyncio.sleep(interval_seconds)
                    continue
                await gods_hand_once(user_id, config, dbi)
            except Exception as e:
                # Log loop error
                err_log = Log(
                    timestamp=datetime.utcnow(),
                    category=LogCategory.BOT,
                    level=LogLevel.ERROR,
                    message=f"Gods Hand loop error: {str(e)}",
                    user_id=user_id,
                    bot_type="gods_hand",
                )
                dbi.add(err_log)
                dbi.commit()
            finally:
                dbi.close()

            await asyncio.sleep(interval_seconds)
    except asyncio.CancelledError:
        pass
    finally:
        bot_status[key] = "stopped"


async def start_gods_hand_entry(user_id: int, db: Session, continuous: bool = True, interval_seconds: int = 60) -> dict:
    """Entry point: runs once and optionally starts background loop."""
    # Ensure not already running
    key = f"gods_hand_{user_id}"
    if continuous and key in bot_tasks:
        return {"status": "running", "message": "Gods Hand already running"}

    config = db.query(BotConfig).filter(BotConfig.user_id == user_id).first()
    if not config or not config.gods_hand_enabled:
        return {"status": "error", "message": "Gods Hand not enabled"}

    # Immediate one-off run to provide UI feedback
    result = await gods_hand_once(user_id, config, db)

    # Start background loop if requested
    if continuous:
        task = asyncio.create_task(_gods_hand_loop(user_id, interval_seconds))
        bot_tasks[key] = task
        bot_status[key] = "running"

    return result


async def stop_bot(bot_type: str, user_id: int, db: Session) -> dict:
    """Stop a running bot"""
    bot_key = f"{bot_type}_{user_id}"
    
    if bot_key in bot_status:
        bot_status[bot_key] = "stopped"
        
        # Cancel any background tasks
        if bot_key in bot_tasks:
            bot_tasks[bot_key].cancel()
            del bot_tasks[bot_key]
        
        return {
            "status": "success",
            "message": f"{bot_type} bot stopped"
        }
    else:
        return {
            "status": "info",
            "message": f"{bot_type} bot is not running"
        }


async def get_bot_status(user_id: int, db: Session) -> dict:
    """Get status of all bots for user"""
    return {
        "grid": bot_status.get(f"grid_{user_id}", "stopped"),
        "dca": bot_status.get(f"dca_{user_id}", "stopped"),
        "gods_hand": bot_status.get(f"gods_hand_{user_id}", "stopped"),
        "timestamp": datetime.utcnow().isoformat()
    }
